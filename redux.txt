- изменяемость через редьюсеры только, чтобы никто не засрал store, от него все приложение зависит
- Если в туториалах встречаешь слова class, extend  и this

всё состояние приложения (state) хранится в единственном месте - сторе (storе). Приложение строится по однонаправленному 
потоку данных, а именно - экшн-редьюсер-стор (все это вызывается функцией диспатч dispatch(action)). Состояние приложения 
нельзя изменять напрямую
а нужно сгенерировать событие (экшн (обычный JavaScript объект)) с описанием изменения (вызывается функцией диспатчером).
Экшн может содержать любые поля, которые будут описывать изменение, единственное обязательное поле — type.
Экшн описывает факт, что что-то произошло, но не указывает, как состояние приложения должно измениться в ответ, 
это работа для редюсера.  
.
Все изменения обрабатываются 
функцией (редьюсером). Редьюсер обрабатывает каждый экшн, который происходит в приложении. Редьюсер принимает на вход 
текущее состояние приложения и экшн который только что произошел (function reducer (state, action)) и для каждого типа экшена 
изменяет состояние switch (action.type). 
Состояние не изменяется напрямую, а возвращается новое состояние, которым Редакс уже сам заменяет старое (return). В редьюсере 
всегда должны возвращать новый объект, а не измененный предыдущий.
.
function reducer(state, action) {
	switch (action.type) {
	 case 'INCREMENT':
	  return {number: state.number + action.by};
	 default: 
	  return state;
	}
}

Объект, который возвращаем в редьюсере, далее с помощью функции connect, превратится в свойства для компонентов.
.
Как итог: Случилось действие от юзера - полетел экшен, экшен был пойман редьюсером - изменились пропсы у 
React-компонента -> компонент перерисовался


Разбираю сейчас у минина метод мэп в массивах и он очень мне напомнил идеалогию ридакса. Коргда метод мэп всегда возвращает новый массив. 

const cars = ['Toyota', 'Mazda', 'Ford', 'BMW']
const upperCaseCars = cars.map(car => {          
  return car.toUpperCase()